// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.11
// Project name: core135_start_ui
/*
* SPDX-FileCopyrightText: 2024 M5Stack Technology CO LTD
*
* SPDX-License-Identifier: MIT
*/
#include "ui.h"

#include "ui_helpers.h"

///////////////////// VARIABLES ////////////////////

lv_obj_t *ui_Screen1;
lv_obj_t *ui_Screen2;
lv_obj_t *ui_Screen3;
lv_obj_t *ui_Screen4;
lv_obj_t *ui_Screenvoid;
lv_obj_t *ui_Tileview1;
lv_obj_t *ui_TabPage[20];
lv_obj_t *ui_Container[20];
lv_obj_t *ui_Image[30];
lv_obj_t *ui_Label[20];
lv_obj_t *ui_Label1;
lv_obj_t *ui_Label2;
lv_obj_t *ui_Label3;
lv_obj_t *ui_Button[20];
lv_obj_t *ui_TextArea[20];
lv_obj_t *led[20];

lv_obj_t *ui_Label21;
lv_obj_t *ui_Label22;

lv_obj_t *ui_TextArea485[12];
lv_obj_t *ui_TextAreacan[12];

lv_obj_t *ui_Checkbox4;
lv_obj_t *ui_Checkbox6;
lv_obj_t *ui_Checkbox7;

lv_obj_t *ui_Button1;
lv_obj_t *ui_TabPage2;
lv_obj_t *ui_TabPage3;
lv_obj_t *ui_Image2;
lv_obj_t *ui_Image3;
lv_obj_t *ui_Image4;
lv_obj_t *ui_Image5;
lv_obj_t *ui____initial_actions0;

///////////////////// TEST LVGL SETTINGS ////////////////////
#if LV_COLOR_DEPTH != 16
#error "LV_COLOR_DEPTH should be 16bit to match SquareLine Studio's settings"
#endif
#if LV_COLOR_16_SWAP != 0
#error "LV_COLOR_16_SWAP should be 0 to match SquareLine Studio's settings"
#endif

///////////////////// ANIMATIONS ////////////////////
extern void (*evdev_call)(int);

void down_button_event(int point_x) {
    switch (point_x) {
        case 0 ... 80:
            if (lv_obj_has_state(ui_Checkbox4, LV_STATE_CHECKED))
                lv_obj_clear_state(ui_Checkbox4, LV_STATE_CHECKED);
            else
                lv_obj_add_state(ui_Checkbox4, LV_STATE_CHECKED);
            break;
        case 81 ... 160:
            if (lv_obj_has_state(ui_Checkbox6, LV_STATE_CHECKED))
                lv_obj_clear_state(ui_Checkbox6, LV_STATE_CHECKED);
            else
                lv_obj_add_state(ui_Checkbox6, LV_STATE_CHECKED);
            break;
        case 161 ... 1000:
            if (lv_obj_has_state(ui_Checkbox7, LV_STATE_CHECKED))
                lv_obj_clear_state(ui_Checkbox7, LV_STATE_CHECKED);
            else
                lv_obj_add_state(ui_Checkbox7, LV_STATE_CHECKED);
            break;
        default:
            break;
    }
}
///////////////////// FUNCTIONS ////////////////////
#include <time.h>
char *get_times() {
    static char time_buff[16];
    time_t now           = time(NULL);
    struct tm *tm_struct = localtime(&now);
    strftime(time_buff, 9, "%H:%M:%S", tm_struct);
    return time_buff;
}
void get_memory_info(unsigned long *total_memory, unsigned long *free_memory) {
    FILE *meminfo = fopen("/proc/meminfo", "r");
    if (meminfo == NULL) {
        perror("fopen");
        exit(1);
    }
    char line[256];
    while (fgets(line, sizeof(line), meminfo)) {
        if (strncmp(line, "MemTotal:", 9) == 0) {
            sscanf(line, "MemTotal: %lu kB", total_memory);
        }
        if (strncmp(line, "MemAvailable:", 13) == 0) {
            sscanf(line, "MemAvailable: %lu kB", free_memory);
            break;  // Exit the loop when available memory information is found.
        }
    }
    fclose(meminfo);
}

void ui_event_test_lcd(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target           = lv_event_get_target(e);
    if (event_code == LV_EVENT_CLICKED) {
        screen_switch_event(e);
    }
}

void ui_event_Screen_lcd(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target           = lv_event_get_target(e);
    if (event_code == LV_EVENT_CLICKED) {
        screen_switch_event(e);
    }
}

int page_lock = -1;

void ui_event_Tileview1(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target           = lv_event_get_target(e);
    if (event_code == LV_EVENT_SCROLL) {
        if (page_lock >= 0) {
            lv_obj_set_tile_id(ui_Tileview1, page_lock, 0, LV_ANIM_OFF);
        }
        for (int i = 0; i < FUN_NUMBER; i++) {
            if (lv_tileview_get_tile_act(ui_Tileview1) == ui_TabPage[i]) {
                lv_led_on(led[i]);
            } else {
                lv_led_off(led[i]);
            }
        }
    }
}

void ui_event_test_bus(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target           = lv_event_get_target(e);
    if (event_code == LV_EVENT_CLICKED) {
        screen_test_bus_event(e);
    }
}

void lvgl_task_get_time_cb(lv_timer_t *tmr) {
    lv_label_set_text(ui_Label1, get_times());
}
struct cpu_use_t {
    long double a[4];
    long time;
};

void lvgl_task_get_system_cb(lv_timer_t *tmr) {
    char cpu_str[16];
    char mem_str[16];
    unsigned long one;
    unsigned long two;
    static struct cpu_use_t laster = {0};
    struct cpu_use_t now;
    long double loadavg;

    FILE *fp = fopen("/proc/stat", "r");
    fscanf(fp, "%*s %Lf %Lf %Lf %Lf", &now.a[0], &now.a[1], &now.a[2],
           &now.a[3]);
    fclose(fp);
    now.time = LV_TICK_CUSTOM_SYS_TIME_EXPR;
    if (laster.time != 0) {
        loadavg = ((now.a[0] + now.a[1] + now.a[2]) -
                   (laster.a[0] + laster.a[1] + laster.a[2])) /
                  ((now.a[0] + now.a[1] + now.a[2] + now.a[3]) -
                   (laster.a[0] + laster.a[1] + laster.a[2] + laster.a[3]));
        sprintf(cpu_str, "%d%%", (int)(loadavg * 100));
        lv_label_set_text(ui_Label2, cpu_str);
        memcpy(&laster, &now, sizeof(struct cpu_use_t));
        get_memory_info(&one, &two);
        float use = ((one * 1.0f) - (two * 1.0f)) / (one * 1.0f);
        sprintf(mem_str, "%d%%", (int)(use * 100));
        lv_label_set_text(ui_Label3, mem_str);
    } else {
        memcpy(&laster, &now, sizeof(struct cpu_use_t));
    }

    FILE *tempinfo = fopen("/sys/class/thermal/thermal_zone0/temp", "r");
    uint32_t temp;
    if (tempinfo != NULL) {
        fscanf(tempinfo, "%u", &temp);
        sprintf(cpu_str, "%dÂ°C", (int)(temp / 1000));
        lv_label_set_text(ui_Label21, cpu_str);
        fclose(tempinfo);
    }
}

#include <linux_i2c/linuxi2c.h>
#include <math.h>
static int battery_stat = 0;

int battery_map(int x, int in_min, int in_max, int out_min, int out_max) {
    // Perform more precise calculations using floating-point numbers.
    float ratio  = (float)(x - in_min) / (in_max - in_min);
    float result = ratio * (out_max - out_min) + out_min;
    // Use the round function for rounding and convert the result to an integer.
    return (int)round(result);
}

void ui_event_main10_timer_callback(lv_timer_t *timer) {
    // Perform the operation to be executed when the timer triggers here.
    LINUXI2CDevice i2cdev;
    char tmp_str[100];
    int ret;
    // init bus object
    linuxi2c_init_device(&i2cdev);
    // open bus
    i2cdev.bus = linuxi2c_open("/dev/i2c-0");
    if (i2cdev.bus <= 0) {
        printf("i2c bus: /dev/i2c-0 open fail!\b");
        return;
    }
    // printf("\r\n");
    i2cdev.addr = 0x34;
    uint8_t data[2];
    data[0] = 0xff;
    linuxi2c_write(&i2cdev, 0x30, &data, 1);
    data[0] = 0x1E;
    linuxi2c_write(&i2cdev, 0x50, &data, 1);

    int reg = 0x34;
    linuxi2c_read(&i2cdev, reg, &data, 2);
    float vbat = (((data[0] & 0x3f) << 8) | data[1]) * 1.0f;
    // printf("vbat: \t%.02fV \n" ,(vbat/1000*1.0f));
    // sprintf(tmp_str, "%.02f V", (vbat/1000*1.0f));
    // lv_label_set_text(ui_Label23, tmp_str);
    int tmp_mk = (int)round(vbat / 10 * 1.0f);
    // printf("tmp_mk 1:%d\n", tmp_mk);
    tmp_mk = tmp_mk > 420 ? 420 : tmp_mk;
    tmp_mk = tmp_mk < 370 ? 370 : tmp_mk;

    int tmp_md = battery_map(tmp_mk, 370, 420, 0, 100);
    sprintf(tmp_str, "%d%%", tmp_md);

    lv_label_set_text(ui_Label22, tmp_str);

    // printf("tmp_mk 2:%d\n", tmp_mk);
    // lv_arc_set_value(ui_Arc5, tmp_mk);

    reg = 0x01;
    linuxi2c_read(&i2cdev, reg, &data, 1);
    uint32_t val = (data[0] >> 5) & 0b11;
    // 0b01:charge / 0b10:dischage / 0b00:stanby
    switch (val) {
        case 0b01:
            if (battery_stat != 0) {
                battery_stat = 0;
                lv_img_set_src(ui_Image[29], &battery1);
            }
            // printf("getChargeStatus :charge\r\n");
            break;
        case 0b10:
            if (battery_stat != 1) {
                battery_stat = 1;
                lv_img_set_src(ui_Image[29], &battery3);
            }
            // printf("getChargeStatus :dischage\r\n");
            break;
        case 0b00:
            if (battery_stat != 2) {
                battery_stat = 2;
                lv_img_set_src(ui_Image[29], &battery3);
            }
            // printf("getChargeStatus :stanby\r\n");
            break;
        default:
            break;
    }

    linuxi2c_close(i2cdev.bus);
}

///////////////////// SCREENS ////////////////////

void ui_init(void) {
    LV_EVENT_GET_COMP_CHILD = lv_event_register_id();

    lv_disp_t *dispp  = lv_disp_get_default();
    lv_theme_t *theme = lv_theme_default_init(
        dispp, lv_palette_main(LV_PALETTE_BLUE),
        lv_palette_main(LV_PALETTE_RED), false, LV_FONT_DEFAULT);
    lv_disp_set_theme(dispp, theme);
    ui_Screen1_screen_init();
    ui_Screen2_screen_init();
    ui_Screen3_screen_init();
    ui_Screen4_screen_init();
    ui_Screen_void_screen_init();
    ui____initial_actions0 = lv_obj_create(NULL);
    lv_disp_load_scr(ui_Screen1);
    lv_timer_create(lvgl_task_get_time_cb, 100, NULL);
    lv_timer_create(lvgl_task_get_system_cb, 1000, NULL);
    lv_timer_create(ui_event_main10_timer_callback, 1000, NULL);
    evdev_call = down_button_event;
}
