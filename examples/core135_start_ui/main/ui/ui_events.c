// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.11
// Project name: core135_start_ui

#include <arpa/inet.h>
#include <fcntl.h>
#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

#include "ui.h"

extern pthread_mutex_t device_thread_mutex;

void screen_switch_event(lv_event_t *e) {
    static int count = 0;
    switch (count) {
        case 0:
            lv_disp_load_scr(ui_Screen2);
            count++;
            break;
        case 1:
            lv_disp_load_scr(ui_Screen3);
            count++;
            break;
        case 2:
            lv_disp_load_scr(ui_Screen4);
            count++;
            break;
        case 3:
            lv_disp_load_scr(ui_Screen1);
            count = 0;
            break;
        default:
            break;
    }
}
//    lv_obj_add_state(ui_Button9, LV_STATE_DISABLED);
//    lv_obj_clear_state(ui_Button7, LV_STATE_DISABLED);
extern int page_lock;
void screen_test_bus_event(lv_event_t *e) {
    static int status = 0;
    switch (status) {
        case 0: {
            page_lock = 3;
            // lv_obj_set_style_bg_color(ui_Container[3],
            // lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_color(ui_Button[2], lv_color_hex(0xF8BE4E),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            system("cd /usr/local/m5stack/dist ; ./bus_test.sh start");
            status++;
        } break;
        case 1: {
            page_lock = -1;
            // lv_obj_set_style_bg_color(ui_Container[3],
            // lv_color_hex(0xD9D9D9), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_color(ui_Button[2], lv_color_hex(0x3B93EE),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            system("cd /usr/local/m5stack/dist ; ./bus_test.sh stop");
            status = 0;
        } break;
        default:
            break;
    }
}

pthread_t test_usb_head;
static void *test_usb_pthread(void *arg) {
    FILE *fstream = (FILE *)arg;
    char buffer[256];
    int device_count = 0;
    for (;;) {
        memset(buffer, 0, sizeof(buffer));
        char *ret = fgets(buffer, sizeof(buffer), fstream);
        // memset(buff, 0, sizeof(buff));
        // int len = fread(buff, sizeof(char), sizeof(buff), fstream);
        if (ret) {
            if ((strstr(buffer, "hub") == NULL) &&
                (strstr(buffer, "Hub") == NULL)) {
                pthread_mutex_lock(&device_thread_mutex);
                lv_textarea_add_text(ui_TextArea[8], buffer);
                pthread_mutex_unlock(&device_thread_mutex);
                device_count++;
            }
        } else {
            pclose(fstream);
            pthread_mutex_lock(&device_thread_mutex);
            if (device_count == 0) {
                lv_textarea_add_text(ui_TextArea[8], "not found usb device!\n");
            } else {
                sprintf(buffer, "%d devices found!\n", device_count);
                lv_textarea_add_text(ui_TextArea[8], buffer);
            }
            if (device_count >= 6) {
                // lv_obj_set_style_bg_color(ui_Button[7], lv_color_hex(0xFF00),
                // LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_color(ui_Container[8], lv_color_hex(0xFF00),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            } else if (device_count == 5) {
                lv_obj_set_style_bg_color(ui_Container[8],
                                          lv_color_hex(0xFFBA34),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                // lv_obj_set_style_bg_color(ui_Button[7],
                // lv_color_hex(0xFF0000), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_color(ui_Container[8],
                                          lv_color_hex(0xFF0000),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            }

            lv_obj_clear_state(ui_Button[7], LV_STATE_DISABLED);
            page_lock = -1;
            pthread_mutex_unlock(&device_thread_mutex);
            break;
        }
    }
}

void screen_test_usb_event(lv_event_t *e) {
    lv_obj_set_style_bg_color(ui_Container[8], lv_color_hex(0xADABEF),
                              LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(ui_TextArea[8], "scan usb device ...\n");
    lv_obj_add_state(ui_Button[7], LV_STATE_DISABLED);
    page_lock     = 8;
    FILE *fstream = popen("lsusb", "r");
    if (fstream != NULL) {
        pthread_create(&test_usb_head, NULL, test_usb_pthread, (void *)fstream);
        pthread_detach(test_usb_head);
    } else {
        page_lock = -1;
        lv_obj_clear_state(ui_Button[7], LV_STATE_DISABLED);
        lv_textarea_add_text(ui_TextArea[8], "not found usb device!\n");
        lv_obj_set_style_bg_color(ui_Container[8], lv_color_hex(0xFF0000),
                                  LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

uint64_t p___millis(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    uint64_t tick = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
    return tick;
}
pthread_t test_can0_head;
pthread_t test_can1_head;
static int communication_count = 0;
int txcount_can0               = 0;
int rxcount_can0               = 0;
int txcount_can1               = 0;
int rxcount_can1               = 0;
static void *test_can0_pthread(void *arg) {
    struct ifreq ifr;
    struct sockaddr_can addr;
    char buffer[32];

    pthread_mutex_lock(&device_thread_mutex);

    lv_textarea_add_text(ui_TextAreacan[0], "open ");
    // sprintf(buffer, "T:%d\n", txcount_can0);
    // lv_label_set_text(ui_TextAreacan[4], buffer);
    // sprintf(buffer, "R:%d\n", rxcount_can0);
    // lv_label_set_text(ui_TextAreacan[2], buffer);

    pthread_mutex_unlock(&device_thread_mutex);

    int _can = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (_can > 0) {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextAreacan[0], "success!\n");
        pthread_mutex_unlock(&device_thread_mutex);
    } else {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextAreacan[0], "faile!\n");
        pthread_mutex_unlock(&device_thread_mutex);
        return NULL;
    }
    strcpy(ifr.ifr_name, "can0");
    ioctl(_can, SIOCGIFINDEX, &ifr);
    int flags = fcntl(_can, F_GETFL, 0);
    fcntl(_can, F_SETFL, flags | O_NONBLOCK);
    addr.can_family  = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    bind(_can, (struct sockaddr *)&addr, sizeof(addr));

    sleep(1);
    struct can_frame frame;
    uint8_t msg_data = 0;
    int time_count   = 0;
    while (communication_count) {
        if (time_count++ > 20) {
            time_count    = 0;
            frame.can_id  = 0x80;
            frame.can_dlc = 1;
            frame.data[0] = msg_data++;
            write(_can, &frame, sizeof(frame));
            ++txcount_can0;
            // pthread_mutex_lock(&device_thread_mutex);
            // sprintf(buffer, "T:%d\n", ++txcount_can0);
            // lv_label_set_text(ui_TextAreacan[4], buffer);
            // pthread_mutex_unlock(&device_thread_mutex);
        }
        memset(&frame, 0, sizeof(struct can_frame));
        int nbytes = read(_can, &frame, sizeof(frame));
        if (nbytes > 0) {
            uint8_t tempp = frame.can_id;
            sprintf(buffer, "0x%02x 0x%02x\n", tempp, frame.data[0]);
            ++rxcount_can0;
            pthread_mutex_lock(&device_thread_mutex);
            lv_textarea_add_text(ui_TextAreacan[0], buffer);
            // sprintf(buffer, "R:%d\n", ++rxcount_can0);
            // lv_label_set_text(ui_TextAreacan[2], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
        usleep(50 * 1000);
    }
    close(_can);
    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextAreacan[0], "close\n");
    pthread_mutex_unlock(&device_thread_mutex);

    return NULL;
}
static void *test_can1_pthread(void *arg) {
    struct ifreq ifr;
    struct sockaddr_can addr;
    char buffer[32];

    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextAreacan[1], "open \n");
    // sprintf(buffer, "T:%d\n", txcount_can1);
    // lv_label_set_text(ui_TextAreacan[5], buffer);
    // sprintf(buffer, "R:%d\n", rxcount_can1);
    // lv_label_set_text(ui_TextAreacan[3], buffer);

    pthread_mutex_unlock(&device_thread_mutex);

    int _can = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (_can > 0) {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextAreacan[1], "success!\n");
        pthread_mutex_unlock(&device_thread_mutex);
    } else {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextAreacan[1], "faile!\n");
        pthread_mutex_unlock(&device_thread_mutex);
        return NULL;
    }
    strcpy(ifr.ifr_name, "can1");
    ioctl(_can, SIOCGIFINDEX, &ifr);
    int flags = fcntl(_can, F_GETFL, 0);
    fcntl(_can, F_SETFL, flags | O_NONBLOCK);
    addr.can_family  = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    bind(_can, (struct sockaddr *)&addr, sizeof(addr));

    sleep(1);
    struct can_frame frame;
    uint8_t msg_data = 0;
    int time_count   = 0;
    while (communication_count) {
        if (time_count++ > 20) {
            frame.can_id  = 0x81;
            frame.can_dlc = 1;
            frame.data[0] = msg_data++;
            time_count    = 0;
            write(_can, &frame, sizeof(frame));
            ++txcount_can1;
            // pthread_mutex_lock(&device_thread_mutex);
            // sprintf(buffer, "T:%d\n", ++txcount_can1);
            // lv_label_set_text(ui_TextAreacan[5], buffer);
            // pthread_mutex_unlock(&device_thread_mutex);
        }
        memset(&frame, 0, sizeof(struct can_frame));
        int nbytes = read(_can, &frame, sizeof(frame));
        if (nbytes > 0) {
            uint8_t tempp = frame.can_id;
            sprintf(buffer, "0x%02x 0x%02x\n", tempp, frame.data[0]);
            ++rxcount_can1;
            pthread_mutex_lock(&device_thread_mutex);
            lv_textarea_add_text(ui_TextAreacan[1], buffer);
            // sprintf(buffer, "R:%d\n", ++rxcount_can1);
            // lv_label_set_text(ui_TextAreacan[3], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
        usleep(50 * 1000);
    }
    close(_can);
    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextAreacan[1], "close\n");
    pthread_mutex_unlock(&device_thread_mutex);

    return NULL;
}

void screen_test_can_event(lv_event_t *e) {
    static int status = 0;
    switch (status) {
        case 0: {
            page_lock           = 5;
            communication_count = 1;
            txcount_can0        = 0;
            rxcount_can0        = 0;
            txcount_can1        = 0;
            rxcount_can1        = 0;
            lv_obj_set_style_bg_color(ui_Container[5], lv_color_hex(0xD9D9D9),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_textarea_set_text(ui_TextAreacan[0], "");
            lv_textarea_set_text(ui_TextAreacan[1], "");
            pthread_create(&test_can0_head, NULL, test_can0_pthread, NULL);
            pthread_detach(test_can0_head);
            pthread_create(&test_can1_head, NULL, test_can1_pthread, NULL);
            pthread_detach(test_can1_head);
            lv_obj_set_style_bg_color(ui_Button[4], lv_color_hex(0xF8BE4E),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            status++;
        } break;
        case 1: {
            lv_obj_set_style_bg_color(ui_Button[4], lv_color_hex(0x3B93EE),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            if ((rxcount_can0 == 0) || (rxcount_can0 == 0)) {
                lv_obj_set_style_bg_color(ui_Container[5],
                                          lv_color_hex(0xFF0000),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_bg_color(ui_Container[5], lv_color_hex(0xFF00),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            }
            page_lock           = -1;
            communication_count = 0;
            status              = 0;
        } break;
        default:
            break;
    }

}

#include "linux_uart/linux_uart.h"

pthread_t test_rs485_head;
pthread_t test_uart_head;
static int communication_rs485_count = 0;
int txcount_rs485                    = 0;
int rxcount_rs485                    = 0;
int txcount_uart2                    = 0;
int rxcount_uart2                    = 0;
static void *test_rs485_pthread(void *arg) {
    uart_t par = {.baud       = 115200,
                  .data_bits  = 8,
                  .stop_bits  = 1,
                  .parity     = 'n',
                  .wait_flage = 1};
    char buffer[32];

    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextArea485[0], "open\n");
    sprintf(buffer, "T:%d\n", txcount_rs485);
    // lv_label_set_text(ui_TextArea485[4], buffer);
    sprintf(buffer, "R:%d\n", rxcount_rs485);
    // lv_label_set_text(ui_TextArea485[2], buffer);
    pthread_mutex_unlock(&device_thread_mutex);
    int _serial = linux_uart_init("/dev/ttySTM3", &par);
    if (_serial <= 0) {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextArea485[0], "faile\n");
        pthread_mutex_unlock(&device_thread_mutex);
        return NULL;
    }
    sleep(1);
    uint8_t msg_data = 0;
    int time_count   = 0;
    while (communication_rs485_count) {
        if (time_count++ > 20) {
            msg_data++;
            linux_uart_write(_serial, 1, &msg_data);
            time_count = 0;
            txcount_rs485++;
            pthread_mutex_lock(&device_thread_mutex);
            sprintf(buffer, "T:%d\n", txcount_rs485);
            // lv_label_set_text(ui_TextArea485[4], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
        char c;

        int len = linux_uart_read(_serial, 1, &c);
        if (len > 0) {
            rxcount_rs485++;
            pthread_mutex_lock(&device_thread_mutex);
            sprintf(buffer, "0x%02x\n", c);
            lv_textarea_add_text(ui_TextArea485[0], buffer);
            sprintf(buffer, "R:%d\n", rxcount_rs485);
            // lv_label_set_text(ui_TextArea485[2], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
        usleep(50 * 1000);
    }
    linux_uart_deinit(_serial);
    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextArea485[0], "close\n");
    pthread_mutex_unlock(&device_thread_mutex);

    return NULL;
}
static void *test_uart_pthread(void *arg) {
    uart_t par = {.baud       = 115200,
                  .data_bits  = 8,
                  .stop_bits  = 1,
                  .parity     = 'n',
                  .wait_flage = 1};
    char buffer[32];
    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextArea485[1], "open\n");
    sprintf(buffer, "T:%d\n", txcount_uart2);
    // lv_label_set_text(ui_TextArea485[5], buffer);
    sprintf(buffer, "R:%d\n", rxcount_uart2);
    // lv_label_set_text(ui_TextArea485[3], buffer);
    pthread_mutex_unlock(&device_thread_mutex);
    int _serial = linux_uart_init("/dev/ttySTM0", &par);
    if (_serial <= 0) {
        pthread_mutex_lock(&device_thread_mutex);
        lv_textarea_add_text(ui_TextArea485[1], "faile\n");
        pthread_mutex_unlock(&device_thread_mutex);
        return NULL;
    }
    sleep(1);
    uint8_t msg_data = 0;
    int time_count   = 0;
    while (communication_rs485_count) {
        usleep(5 * 1000);
        if (time_count++ > 200) {
            msg_data++;
            linux_uart_write(_serial, 1, &msg_data);
            time_count = 0;
            txcount_uart2++;
            pthread_mutex_lock(&device_thread_mutex);
            sprintf(buffer, "T:%d\n", txcount_uart2);
            // lv_label_set_text(ui_TextArea485[5], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
        char c;

        int len = linux_uart_read(_serial, 1, &c);
        if (len > 0) {
            rxcount_uart2++;
            pthread_mutex_lock(&device_thread_mutex);
            sprintf(buffer, "0x%02x\n", c);
            lv_textarea_add_text(ui_TextArea485[1], buffer);
            sprintf(buffer, "R:%d\n", rxcount_uart2);
            // lv_label_set_text(ui_TextArea485[3], buffer);
            pthread_mutex_unlock(&device_thread_mutex);
        }
    }
    linux_uart_deinit(_serial);
    pthread_mutex_lock(&device_thread_mutex);
    lv_textarea_add_text(ui_TextArea485[1], "close\n");
    pthread_mutex_unlock(&device_thread_mutex);

    return NULL;
}

void screen_test_rs485_event(lv_event_t *e) {
    static int status = 0;
    switch (status) {
        case 0: {
            page_lock                 = 4;
            communication_rs485_count = 1;
            txcount_rs485             = 0;
            rxcount_rs485             = 0;
            txcount_uart2             = 0;
            rxcount_uart2             = 0;
            lv_obj_set_style_bg_color(ui_Container[4], lv_color_hex(0xD9D9D9),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_bg_color(ui_Button[3], lv_color_hex(0xF8BE4E),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_textarea_set_text(ui_TextArea485[0], "");
            lv_textarea_set_text(ui_TextArea485[1], "");
            pthread_create(&test_rs485_head, NULL, test_rs485_pthread, NULL);
            pthread_detach(test_rs485_head);
            pthread_create(&test_uart_head, NULL, test_uart_pthread, NULL);
            pthread_detach(test_uart_head);

            status++;
        } break;
        case 1: {
            lv_obj_set_style_bg_color(ui_Button[3], lv_color_hex(0x3B93EE),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            page_lock = -1;
            if ((rxcount_rs485 == 0) || (rxcount_uart2 == 0)) {
                lv_obj_set_style_bg_color(ui_Container[4],
                                          lv_color_hex(0xFF0000),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_obj_set_style_bg_color(ui_Container[4], lv_color_hex(0xFF00),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            }
            communication_rs485_count = 0;
            status                    = 0;
        } break;
        default:
            break;
    }
}

pthread_t test_i2c_head;
static void *test_i2c_pthread(void *arg) {
    FILE *fstream = (FILE *)arg;
    char buffer[128];
    char devicestr[64];
    int bufsize;
    int dev_count = 0;
    for (;;) {
        memset(buffer, 0, sizeof(buffer));
        char *ret = fgets(buffer, sizeof(buffer), fstream);
        // printf("%s", buffer);
        // int bytes_read = getline(&buffer, &bufsize, fstream);
        // int len = fread(buff, sizeof(char) , sizeof(buff) , fstream);
        if (ret) {
            char *fstr = strstr(buffer, ":");
            if (fstr != NULL) {
                pthread_mutex_lock(&device_thread_mutex);

                char *token = strtok(fstr + 2, " ");
                while (token != NULL) {
                    // printf("get %s\r\n", token);
                    switch (token[0]) {
                        case 'a' ... 'z':
                        case '0' ... '9': {
                            sprintf(devicestr, "i2c found dev 0x%s\n", token);
                            lv_textarea_add_text(ui_TextArea[7], devicestr);
                            dev_count++;
                        } break;
                        default:
                            break;
                    }
                    token = strtok(NULL, " ");
                }
                pthread_mutex_unlock(&device_thread_mutex);
            }
        } else {
            pclose(fstream);
            pthread_mutex_lock(&device_thread_mutex);
            lv_obj_clear_state(ui_Button[7], LV_STATE_DISABLED);
            page_lock = -1;
            if (dev_count != 0) {
                lv_textarea_add_text(ui_TextArea[7], "i2c test sucess!");

                // lv_obj_set_style_bg_color(ui_Button[6], lv_color_hex(0xff00),
                // LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_color(ui_Container[7], lv_color_hex(0xff00),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            } else {
                lv_textarea_add_text(ui_TextArea[7], "i2c not found device!");
                // lv_obj_set_style_bg_color(ui_Button[6],
                // lv_color_hex(0xff0000), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_obj_set_style_bg_color(ui_Container[7],
                                          lv_color_hex(0xff0000),
                                          LV_PART_MAIN | LV_STATE_DEFAULT);
            }
            pthread_mutex_unlock(&device_thread_mutex);
            break;
        }
    }
    return NULL;
}
void screen_test_i2c_event(lv_event_t *e) {
    page_lock = 7;
    lv_obj_add_state(ui_Button[7], LV_STATE_DISABLED);
    lv_obj_set_style_bg_color(ui_Container[7], lv_color_hex(0xADABEF),
                              LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_textarea_set_text(ui_TextArea[7], "scan i2c dev ...\n");
    FILE *fstream = popen("i2cdetect -y 1", "r");
    if (fstream != NULL) {
        pthread_create(&test_i2c_head, NULL, test_i2c_pthread, fstream);
        pthread_detach(test_i2c_head);
    } else {
        lv_textarea_add_text(ui_TextArea[7], "i2c error!");
        lv_obj_clear_state(ui_Button[7], LV_STATE_DISABLED);
        lv_obj_set_style_bg_color(ui_Container[7], lv_color_hex(0xff0000),
                                  LV_PART_MAIN | LV_STATE_DEFAULT);
        page_lock = -1;
    }
}

char *get_IP_eth0_address(int num) {
    int fd;
    struct ifreq ifr;
    fd = socket(AF_INET, SOCK_DGRAM, 0);
    /* I want to get an IPv4 IP address */
    ifr.ifr_addr.sa_family = AF_INET;
    /* I want IP address attached to "eth0" */
    switch (num) {
        case 0:
            strncpy(ifr.ifr_name, "eth0", IFNAMSIZ - 1);
            break;
        case 1:
            strncpy(ifr.ifr_name, "eth1", IFNAMSIZ - 1);
            break;
        case 2:
            strncpy(ifr.ifr_name, "wlan0", IFNAMSIZ - 1);
            break;
        default:
            break;
    }
    ioctl(fd, SIOCGIFADDR, &ifr);
    close(fd);
    /* display result */
    static char ip_address[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr),
              ip_address, INET_ADDRSTRLEN);
    // printf("%s\n", ip_address);
    return ip_address;
}

void screen_test_rtc_event(lv_event_t *e) {
    char cmdstr[256] = {0};
    sprintf(cmdstr,
            "/bin/sh -c \"sleep 1; hwclock -w ; sleep 1 ; echo +10 > "
            "/sys/class/rtc/rtc0/wakealarm ; cat /dev/zero > /dev/fb1 ; "
            "poweroff\" &> /dev/null &");
    system(cmdstr);
    exit(0);
}

pthread_t test_play_head;
static void *test_play_pthread(void *arg) {

    system("tinyplay /usr/local/m5stack/chexian.wav");
    pthread_mutex_lock(&device_thread_mutex);
    lv_obj_clear_state(ui_Button[10], LV_STATE_DISABLED);
    pthread_mutex_unlock(&device_thread_mutex);
}

void screen_test_play_event(lv_event_t *e) {
    lv_obj_add_state(ui_Button[10], LV_STATE_DISABLED);
    // lv_textarea_add_text(ui_TextArea[9], "tinyplay
    // /usr/local/m5stack/chexian.wav\n"); FILE *fstream = popen("tinyplay
    // /usr/local/m5stack/chexian.wav", "r"); if (fstream != NULL)
    // {
    pthread_create(&test_play_head, NULL, test_play_pthread, NULL);
    pthread_detach(test_play_head);
    // }
}

void screen_test_touch_event(lv_event_t *e) {
    lv_disp_load_scr(ui_Screenvoid);
    system(
        "/bin/sh -c \"sleep 1 ; cd /usr/local/m5stack/arm32-tslib ; . "
        "./bash.bash ; cd /usr/local/m5stack/arm32-tslib/bin ; ./ts_test ; cd "
        "/usr/local/m5stack/dist ; ./core135_start_ui 1 &\" &> /dev/null &");
    exit(0);
}

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

int get_pid_by_procname(const char *procname) {
    DIR *dir;
    struct dirent *entry;
    char path[256];
    char cmdline[1024];
    int pid = -1;

    // open /proc
    dir = opendir("/proc");
    if (dir == NULL) {
        perror("Failed to open /proc");
        return -1;
    }

    // Traverse all directories under /proc.
    while ((entry = readdir(dir)) != NULL) {
        int id = atoi(
            entry
                ->d_name);  // Try to convert directory names to integers (PID).
        if (id > 0) {
            // Construct the path to the cmdline file.
            snprintf(path, sizeof(path), "/proc/%d/cmdline", id);
            FILE *fp = fopen(path, "r");
            if (fp) {
                if (fgets(cmdline, sizeof(cmdline), fp) != NULL) {
                    if (strstr(cmdline, procname) != NULL) {
                        pid = id;  // Find the matching process.
                        fclose(fp);
                        break;
                    }
                }
                fclose(fp);
            }
        }
    }

    closedir(dir);
    return pid;
}

pthread_t test_cpu_head;
static int cpu_flage = 0;
static void *test_cpu_pthread(void *arg) {
    system("cp /usr/local/m5stack/chexian.wav /tmp/");
    while (cpu_flage) {
        system("tinyplay /tmp/chexian.wav");
        if (get_pid_by_procname("bc") <= 0) {
            system("echo \"scale=20000; 4*a(1)\" | bc -l -q &> /dev/null &");
        }
        // system("ps ax | grep 'bc' | grep -v grep || echo \"scale=2000;
        // 4*a(1)\" | bc -l -q &> /dev/null &");
    }
    system("killall bc");
}

void screen_test_cpu_event(lv_event_t *e) {
    static int status = 0;
    switch (status) {
        case 0: {
            page_lock = 10;
            cpu_flage = 1;
            lv_obj_set_style_bg_color(ui_Button[11], lv_color_hex(0xF8BE4E),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            pthread_create(&test_cpu_head, NULL, test_cpu_pthread, NULL);
            pthread_detach(test_cpu_head);
            status++;
        } break;
        case 1: {
            page_lock = -1;
            cpu_flage = 0;
            lv_obj_set_style_bg_color(ui_Button[11], lv_color_hex(0x3B93EE),
                                      LV_PART_MAIN | LV_STATE_DEFAULT);
            status = 0;
        } break;
        default:
            break;
    }
}